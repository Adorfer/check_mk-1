#!/usr/bin/python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2014             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# ails.  You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.

# Author: Christian Burmeister

class STP_SNMP(object):
        # http://www.cisco.com/c/en/us/support/docs/ip/simple-network-management-protocol-snmp/44800-mactoport44800.html

        def __init__(self, ip_address, snmp_credentials):
            self.__ip_address      = ip_address
            self.__snmp_credentials  = snmp_credentials
	    self.__all_vlans       = []

        def __get_oid(self, oid, index = ""):

	    if index != "":
		context_v2 = "@" + index
		context_v3 = "vlan-" + index
	    else:
		context_v2 = ""
		context_v3 = ""


	    version = 1
	    timeout = timeout = int(1 * 1000000) # default: 1 second
	    retries = 3	
 	    if type(self.__snmp_credentials) in (str, unicode):
		version = 2
    	    else:
        	version = 3
        	if len(self.__snmp_credentials) == 6:
            		sec_level, auth_proto, sec_name, auth_pass, priv_proto, priv_pass = self.__snmp_credentials
        	elif len(self.__snmp_credentials) == 4:
            		sec_level, auth_proto, sec_name, auth_pass = self.__snmp_credentials
            		priv_proto = 'DEFAULT'
            		priv_pass  = ''
        	else:
            		raise MKGeneralException("Invalid SNMP credentials '%r' for ip %s: "
                              "must be string, 4-tuple or 6-tuple" % (self.__snmp_credentials, self.__ip_address))

		


    	    if version != 3:
		print self.__ip_address, self.__snmp_credentials + context_v2, oid
        	session = netsnmp.Session(Version = version, DestHost = self.__ip_address,
            		Timeout    = timeout,
            		Retries    = retries,
            		Community  = self.__snmp_credentials + context_v2,
        	)
      	    else:
        	session = netsnmp.Session(Version = version, DestHost = self.__ip_address,
            		Timeout   = timeout,
            		Retries   = retries,
            		SecLevel  = sec_level,
            		AuthProto = auth_proto.upper(),
            		AuthPass  = auth_pass,
            		SecName   = sec_name,
            		PrivProto = priv_proto.upper(),
            		PrivPass  = priv_pass,
            		Context   = context_v3,
        	)


            session.UseLongNames = 1
            session.UseNumeric = 1
            session.Retries=2

	    oid_varlist = netsnmp.VarList(netsnmp.Varbind(oid))

            res = session.walk(oid_varlist)

            result_dict = {}
            i = 0
            for var in oid_varlist:
                if var.tag != None:
                        oid_suffix = var.tag.replace(oid,"") + "." + var.iid

                        if oid_suffix[:1] == ".":
                                oid_suffix = oid_suffix[1:]
                        result_dict[oid_suffix] = res[i]
                        i += 1

            return result_dict

        def __get_vlans(self):
            oid_vtpVlanState = '.1.3.6.1.4.1.9.9.46.1.3.1.1.2'
            vtpVlanState_dict = self.__get_oid(oid_vtpVlanState)


            for oid in vtpVlanState_dict:
                vlan = oid.replace("1.", "")
                self.__all_vlans.append(vlan)


	def get_stp_vlan(self, vlan):
	
		dot1dStp_base = ".1.3.6.1.2.1.17.2."

        	dot1dStp_dict = {
                        1 : "dot1dStpProtocolSpecification",
                        2 : "dot1dStpPriority",
                        3 : "dot1dStpTimeSinceTopologyChange",
                        4 : "dot1dStpTopChanges",
                        5 : "dot1dStpDesignatedRoot",
                        6 : "dot1dStpRootCost",
                        7 : "dot1dStpRootPort",
        	}

		for key, value in dot1dStp_dict.items():

			if vlan == None:
				print self.__get_oid(dot1dStp_base + str(key))
	

	def get_all_stp_vlans(self):
		self.__get_vlans()
		
		self.get_stp_vlan(None)

		


def decode_bridgePriorityAddress(value):
	bridgeID = "".join ([ "%02X" % ord( x ) for x in list(value)])


	bridePrioirty	= None
	bridgeAddress 	= None

	if len(bridgeID) == 16:
        	bridePriority_hex      = bridgeID[:4]
     		bridePrioirty          = int("0x" + bridePriority_hex.lower(), 0)
        	bridgeAddress_hex      = bridgeID[4:].upper()
        	bridgeAddress          = "%s%s:%s%s:%s%s:%s%s:%s%s:%s%s" % (tuple(list(bridgeAddress_hex)))

	elif len(bridgeID) == 12:
		bridgeAddress_hex      = bridgeID.upper()
                bridgeAddress          = "%s%s:%s%s:%s%s:%s%s:%s%s:%s%s" % (tuple(list(bridgeAddress_hex)))


	return (bridePrioirty, bridgeAddress)

def decode_timeticks(value):
	timeticks = saveint(value)

      	timeticks_string = ""
     	d, m = divmod(timeticks, 8640000)
      	timeticks_string += '%dD/' % d
       	d, m = divmod(m, 360000)
       	timeticks_string += '%dH/' % d
       	d, m = divmod(m, 6000)
       	timeticks_string += '%dM/' % d
     	d, m = divmod(m, 100)
      	timeticks_string += '%dS' % d

	return timeticks_string 

def parse_cisco_stp(info):
	(if_info, dot1dStp_1_info, dot1dStp_2_info) = info

 	dot1dStp_dict = {
			1 : "dot1dStpProtocolSpecification",
			2 : "dot1dStpPriority",
			3 : "dot1dStpTimeSinceTopologyChange",
			4 : "dot1dStpTopChanges",
			5 : "dot1dStpDesignatedRoot",
			6 : "dot1dStpRootCost",
                        7 : "dot1dStpRootPort",
                        8 : "dot1dStpMaxAge",
                        9 : "dot1dStpHelloTime",
	}

	stp_dict = {}
	
	for i in range(len(dot1dStp_2_info[0])):
		key = dot1dStp_dict[i+1] 
		value = dot1dStp_2_info[0][i]

		if key == "dot1dStpDesignatedRoot":
			(bridgePriority, bridgeAddress) = decode_bridgePriorityAddress(value)
			value = str(bridgePriority) + "-" + bridgeAddress
		elif key == "dot1dStpTimeSinceTopologyChange":
			value = decode_timeticks(value)
	
		stp_dict.update( { key : value } )
	
	
	
	(bridgePriority, bridgeAddress) = decode_bridgePriorityAddress(dot1dStp_1_info[0][0])


	dot1dStpProtocolSpecification_dict = { "1":"unknown", "2":"decLb100", "3":"ieee8021d" } 

	stp_general = (bridgeAddress, dot1dStpProtocolSpecification_dict[stp_dict["dot1dStpProtocolSpecification"]])

	if  dot1dStpProtocolSpecification_dict[stp_dict["dot1dStpProtocolSpecification"]] == "ieee8021d":
		return (if_info, { "VLAN ALL" : stp_dict} , stp_general) 
	elif dot1dStpProtocolSpecification_dict[stp_dict["dot1dStpProtocolSpecification"]] == "decLb100":
		return (if_info, { "VLAN ALL" : stp_dict} , stp_general)
	elif dot1dStpProtocolSpecification_dict[stp_dict["dot1dStpProtocolSpecification"]] == "unknown":
		ip_address = lookup_ip_address(g_hostname)
        	snmp_credentials = snmp_credentials_of(g_hostname)
        	stp_vlan_dict = STP_SNMP(ip_address, snmp_credentials).get_all_stp_vlans()

		return (if_info, stp_vlan_dict , stp_general)
	else:
		return None




def inventory_cisco_stp(parsed):

	(if_info, stp_vlan_dict, stp_general) = parsed

	inventory = []
	inventory.append( ("general", None) )


	for vlan in stp_vlan_dict:
		inventory.append( (vlan, None) )
			

	return inventory


def check_cisco_stp(item, params, parsed):

	(if_info, stp_vlan_dict, stp_general) = parsed

	if item == "general":
		msg = "BridgeAddress: %s, Protocol: %s" % stp_general

		return 0, msg

	elif item in stp_vlan_dict:
		msg = []
		msg.append( "Priority: %s"     % stp_vlan_dict[item]["dot1dStpPriority"] )
                msg.append( "RootBridgeID: %s" % stp_vlan_dict[item]["dot1dStpDesignatedRoot"] )
		msg.append( "RootPort: %s"     % stp_vlan_dict[item]["dot1dStpRootPort"] )
                msg.append( "RootPathCost: %s" % stp_vlan_dict[item]["dot1dStpRootCost"] )
                msg.append( "TopChange: %s"    % stp_vlan_dict[item]["dot1dStpTopChanges"] )
		msg.append( "TopLastChange: %s" % stp_vlan_dict[item]["dot1dStpTimeSinceTopologyChange"] )

		return 0, ", ".join(msg)
	
	else:	
		return 3, "STP data not found"


check_info["cisco_stp"] = {
    'check_function'            : check_cisco_stp,
    'inventory_function'        : inventory_cisco_stp,
    'parse_function'            : parse_cisco_stp,
    'service_description'       : "STP %s",
#    'has_perfdata'              : True,
    'snmp_info'                 : [(".1.3.6.1.2.1", if64_snmp_end_oids),
				   (".1.3.6.1.2.1.17.1", [ "1"]),
				   (".1.3.6.1.2.1.17.2", [ "1","2","3","4","5", "6", "7", "8", "9"]),
                                  ],
    'snmp_scan_function'        : lambda oid: if64_scan_function(oid, False),
#    'group'                     : 'if',
#    'default_levels_variable'   : 'if_default_levels',
}

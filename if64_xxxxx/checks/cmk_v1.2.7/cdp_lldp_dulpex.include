#!/usr/bin/python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2014             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# ails.  You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.

"""
def fix_if64_highspeed(info):
    for line in info:
        if type(line[4]) == str: # not yet converted
            line[4] = saveint(line[4]) * 1000000


def inventory_if64(info):
    # Fix for switches like DLINK, with empty lines in MIB
    info = [ x for x in info if saveint(x[1]) > 0 ]
    fix_if64_highspeed(info)
    return inventory_if_common(info, has_nodeinfo = True)

def check_if64(item, params, info):
    fix_if64_highspeed(info)
    return check_if_common(item, params, info, has_nodeinfo = True)

def if64_scan_function(oid):
    ignored_strings = [
    "LANCOM",
    "Brocade VDX Switch",
    ]
    for string in ignored_strings:
        if string in oid(".1.3.6.1.2.1.1.1.0"):
            return False

    if ".4.1.11863." in oid(".1.3.6.1.2.1.1.2.0"):
        return False

    if if64_disabled(g_hostname):
        return False

    if oid(".1.3.6.1.2.1.31.1.1.1.6.*") != None:
        return True
    return False
"""

def inventory_if64_original(info):
    parse_if64(info)
    return inventory_if_common(parse_if64(info), has_nodeinfo = True)

def check_if64_original(item, params, info):
    return check_if_common(item, params, parse_if64(info), has_nodeinfo = True)

def if64_scan_function_orignial(oid):
    return if64_scan_function(oid, False)

#---Eigene Methoden-----------------------------------------------------------------------

oid_vlanTrunkPortDynamicStatus = (".1.3.6.1.4.1.9.9.46.1.6.1.1",   [OID_END, "14"])   #Cisco: vlanTrunkPortDynamicStatus 
oid_dot3adAggPortSelectedAggID = (".1.2.840.10006.300.43.1.2.1.1", [OID_END, "12"])   #Cisco: dot3adAggPortSelectedAggID
oid_dot1qVlanStaticEntry       = (".1.3.6.1.2.1.17.7.1.4.3.1",     [OID_END, "4" ])   #HP: dot1qVlanStaticEntry
oid_lldpRemSysName             = (".1.0.8802.1.1.2.1.4.1.1",       [OID_END, "8", "9", "10" ])   #HP: lldpRemSysName
oid_cdpCacheDeviceId           = (".1.3.6.1.4.1.9.9.23.1.2.1.1",   [OID_END, "6", "7", "8" ])   #Cisco: cdpCacheDeviceId
oid_dot3StatsDuplexStatus      = (".1.3.6.1.2.1.10.7.2.1",         [OID_END, "19"])   #All: dot3StatsDuplexStatus 




def list_find(item, list):
        found = False
        for i in list:
                if item.lower().find(i.lower()) != -1:
                        found = True
                        break

        return found


def get_trunk_cisco(vlanTrunkPortDynamicStatus):
    index_trunks = []

    # find Cisco Trunks
    if len(vlanTrunkPortDynamicStatus) > 0:
        for cisco_if in vlanTrunkPortDynamicStatus:
                if cisco_if == None:
                        continue
                is_cisco_trunk = '1'
                if cisco_if[1] == is_cisco_trunk:
                        index_trunks.append(cisco_if[0])

    return index_trunks

def get_trunk_hp(dot1qVlanStaticEntry):
    index_trunks = []

    if len(dot1qVlanStaticEntry) > 0:
        hp_available_vlan_byte = []
        for hp_vlan in dot1qVlanStaticEntry:
                if hp_vlan == None:
                        continue
                vlan1 = "1"
                if hp_vlan[0] != vlan1:
                        hp_available_vlan_byte.append(hp_vlan)
     
        hp_available_vlan_bin = []
        for vlan_byte in hp_available_vlan_byte:
                # Beispiel vlan_byte = ['10', '\xff\xff\xf8\x00\x00\x00\x00\x00']
                hex_string =  "".join ([ "%02X" % ord( x ) for x in list(vlan_byte[1])])

                # Beispiel hex_string = FFFFF80000000000
                bin_string =  "".join(["{0:04b}".format(int(c,16)) for c in hex_string])
                # Beispiel bin_string = 1111111111111111111110000000000000000000000000000000000000000000
                hp_available_vlan_bin.append(bin_string)

        if len(hp_available_vlan_bin) > 0:
                min_length = len(hp_available_vlan_bin[0])
                for i in range(min_length):
                        if_is_tagged = True
                        for j in range(len(hp_available_vlan_bin)):
                              if_untagged = "1"
                              if hp_available_vlan_bin[j][i] == if_untagged:
                               if_is_tagged = False
                        if if_is_tagged:
                              index_trunks.append(str(i+1)) 

    return index_trunks


def get_port_channel(dot3adAggPortSelectedAggID):
    port_channel = []

    if len(dot3adAggPortSelectedAggID) > 0:
        for cisco_if in dot3adAggPortSelectedAggID:
                if cisco_if == None:
                        continue
                is_no_etherchannel = '0'
                if cisco_if[1] > is_no_etherchannel:
                        port_channel.append(cisco_if[0])

    return port_channel


def get_neighbor_generic(cdp_lldp, typ, neighbor_ignore=[], neighbor_search=[]):
    all_neighbor_if = {}

    if len(cdp_lldp) > 0:
        for neighbor_if in cdp_lldp:
                if neighbor_if == None:
                        continue


                if typ == "LLDP":
                        lldpRemPortDesc = neighbor_if[1]
                        lldpRemSysName  = neighbor_if[2]
                        lldpRemSysDesc  = neighbor_if[3]
                        name     = lldpRemSysName
                        port     = lldpRemPortDesc
                        platform = lldpRemSysDesc

                        # "if_index" von cdp und lldp unterscheiden sich auf Cisco-Switchen (HP sind sie gleich), ich habe bisher
                        # noch keine loesung gefunden die lldp if_indexe auf Cisco-Interface zu mappen, daher werden LLDP-Nachbarn 
                        # bei Cisco Switchen auf falschen Ports erkannt. 
                        # Workaround in get_neighbor_generic_all
                        if_index = neighbor_if[0].split(".")[1]

                elif typ == "CDP":
                        cdpCacheDeviceId   = neighbor_if[1]
                        cdpCacheDeviceId   = cdpCacheDeviceId.split("(")[0]     # Cisco Nexus
                        cdpCacheDevicePort = neighbor_if[2]
                        cdpCachePlatform   = neighbor_if[3]
                        name     = cdpCacheDeviceId
                        port     = cdpCacheDevicePort
                        platform = cdpCachePlatform

                        if_index = neighbor_if[0].split(".")[0]

                if "cisco AIR-CAP" in platform:
                        name = "AP__" + name
                        port = "IGNORE"

                if len(neighbor_search) != 0:
                        if not (list_find(platform,neighbor_search) and not list_find(platform,neighbor_ignore)):
                                continue
                else:
                        if list_find(platform,neighbor_ignore):
                                continue


                name     = name.encode('ascii','ignore').strip()
                port     = port.encode('ascii','ignore').strip()
                platform = platform.encode('ascii','ignore').strip()

                name_printable = ''.join([c for c in name if ord(c) > 31 or ord(c) == 9])
                if len(name_printable) != len(name) or len(name_printable) == 0:
                        continue

                new_neighbor_if = (typ, name, port, platform)
                if if_index in all_neighbor_if.keys():
                        all_neighbor_if[if_index].append(new_neighbor_if)
                else:
                        all_neighbor_if.update( {if_index:[new_neighbor_if]} )

    return all_neighbor_if


def get_neighbor_generic_all(lldpRemSysName, cdpCacheDeviceId, neighbor_ignore=[], neighbor_search=[]):
        neighbor_lldp = get_neighbor_generic(lldpRemSysName, "LLDP", neighbor_ignore, neighbor_search)
        neighbor_cdp  = get_neighbor_generic(cdpCacheDeviceId, "CDP", neighbor_ignore, neighbor_search)

        # Workaround f√ºr Cisco Switche, da LLDP nicht zugeordent werden kann.
        all_neighbor_lldp = []
        for index_neighbor_lldp in neighbor_lldp.keys():
                all_neighbor_lldp.append(neighbor_lldp[index_neighbor_lldp][0][1])

        all_neighbor_cdp = []
        for index_neighbor_cdp in neighbor_cdp.keys():
                all_neighbor_cdp.append(neighbor_cdp[index_neighbor_cdp][0][1])


        if set(all_neighbor_lldp).issubset(all_neighbor_cdp):
                #loesche neighbor_lldp, weil alle Switche wurde bereits mit CDP erkannt wurden
                neighbor_lldp = {}

        return (neighbor_lldp, neighbor_cdp)

def get_neighbor_interface_raw(if_index, neighbor_lldp, neighbor_cdp):

        all_neighbor = []
        for cdp_lldp in [neighbor_lldp, neighbor_cdp]:
                for neighbor_index in cdp_lldp.keys():
                        if neighbor_index == if_index:
                                for neighbor in cdp_lldp[neighbor_index]:
                                        (typ, name, port, platform) = neighbor

                                        all_neighbor.append( (typ, name, port, platform)  )

        return all_neighbor


def get_neighbor_interface_string(if_index, neighbor_lldp, neighbor_cdp, exclude_type = False, include_platform = False):
        all_neighbor = get_neighbor_interface_raw(if_index, neighbor_lldp, neighbor_cdp)

        neighbor_string = []
        for neighbor in sorted(all_neighbor):
                (typ, name, port, platform) = neighbor


                if exclude_type:
                        neighbor_string.append("%s...%s" % (name, port) )
                elif include_platform:
                        neighbor_string.append( "%s: %s...%s (%s)" % (typ, name, port, platform) )
                else:
                        neighbor_string.append( "%s: %s...%s" % (typ, name, port) )


        if exclude_type and len(neighbor_string) == 0:
                return None
        else:
                return  " - ".join(neighbor_string)


def get_neighbor_ifAlias(interface, neighbor_lldp, neighbor_cdp):
        if_alias = interface[18]
        if_index = interface[0]
        ifAlias_raw_neighbor = None
        neighbor_found = False

        neighbor_info_all = []

        neighbor = get_neighbor_interface_string(if_index, neighbor_lldp, neighbor_cdp)

        if len(neighbor) > 0:
                if if_alias != "":
                        if_alias =  "%s -- ifAlias: %s"       % (neighbor, if_alias)
                else:
                        if_alias =  "%s -- ifAlias: NO_ALIAS" % (neighbor,)

                return str(if_alias) 

        else: 
                ifType_ethernet = ["6", "62", "117"]

                if list_find(interface[2], ifType_ethernet):
                        if_alias =  "ifAlias: " + if_alias + " -- NO_CDP-LLDP"
                else:
                        if_alias =  "ifAlias: " + if_alias
                return str(if_alias)





def check_duplex(interface, dot3StatsDuplexStatus):

        if_alias = interface[18]
        if len(dot3StatsDuplexStatus) >= 1:
                for if_duplex in dot3StatsDuplexStatus:
                        if if_duplex != None:
                                if interface[0] == if_duplex[0]:
                                        dot3StatsDuplexStatus_unknown = "1"
                                        dot3StatsDuplexStatus_halfDuplex = "2"
                                        dot3StatsDuplexStatus_fullDuplex = "3"
                                        if if_duplex[1] == dot3StatsDuplexStatus_halfDuplex:
                                                if_alias = "DuplexStats: halfDuplex (!)-- " + if_alias
        return if_alias



def inventory_if64_params_neighbor(if_info, lldpRemSysName, cdpCacheDeviceId, neighbor_ignore, neighbor_search):

    item_params = inventory_if64_original(if_info)

    (neighbor_lldp, neighbor_cdp) = get_neighbor_generic_all(lldpRemSysName, cdpCacheDeviceId,neighbor_ignore, neighbor_search)

    neighbor_map = {}
    for interface in if_info:
        if interface == None:
                continue
        if_descr = interface[2]
        if_index = interface[1]
        neighbor_map[if_descr] =  get_neighbor_interface_string(if_index, neighbor_lldp, neighbor_cdp, True)

    new_item_parmas = []
    for (item, params) in item_params:
        params = eval(params)



        neighbor = {"neighbor": None}
        for ifDescr in neighbor_map.keys():
                if ifDescr == item:
                        if item in neighbor_map.keys():
                                neighbor = {"neighbor": neighbor_map[ifDescr]}
                                break

        params.update(neighbor)
        new_item_parmas.append( (item, params) )

  
    return new_item_parmas


def check_if64_neighbor_interface(interface, lldpRemSysName, cdpCacheDeviceId, neighbor_ignore, neighbor_search, params, item, dot3StatsDuplexStatus=[]):
        warn = 1
        return_state = 4
        output = None

        (neighbor_lldp_all, neighbor_cdp_all) = get_neighbor_generic_all(lldpRemSysName, cdpCacheDeviceId)
        interface[18] = get_neighbor_ifAlias(interface, neighbor_lldp_all, neighbor_cdp_all)

        (neighbor_lldp, neighbor_cdp) = get_neighbor_generic_all(lldpRemSysName, cdpCacheDeviceId, neighbor_ignore, neighbor_search)

        #interface[18] = get_neighbor_ifAlias(interface, neighbor_lldp, neighbor_cdp)

        if len(dot3StatsDuplexStatus) != 0:
                interface[18] = check_duplex(interface, dot3StatsDuplexStatus)


        old_neighbor = str(params.get("neighbor", "NO_NEIGHBOR_SAVED"))
        current_neighbor = str(get_neighbor_interface_string(interface[0], neighbor_lldp, neighbor_cdp, True))


        if old_neighbor !=  current_neighbor:
                interface[18] = "NEIGHBOR_CHANGED: old_neighbor: " + old_neighbor +  " -------------- " + interface[18]

                output = check_if64_original(item, params, [[None] + interface])

                if output[0] < 1:
                        output = (warn,) + output[1:]
                elif output[0] == 2 and output[1].find("(down)(!!)") != -1:
                        output = (output[0], output[1].replace("NEIGHBOR_CHANGED:", "INTERFACE DOWN:") )

        elif interface[18].find("IP Phone") != -1:
                interface[18] = interface[18].replace("IP Phone","IP Phone(!) --Bitte Port als Access-Port konfigurieren!-- ")

                output = check_if64_original(item, params, [[None] + interface])
                if output[0] < 1:
                        output = (warn,) + output[1:]
        elif interface[18].find("DuplexStats:") != -1:
                output = check_if64_original(item, params, [[None] + interface])
                if output[0] < 1:
                        output = (warn,) + output[1:]
        else:
                output = check_if64_original(item, params, [[None] + interface])


        return output